"use strict";(self.webpackChunkactivejdocs=self.webpackChunkactivejdocs||[]).push([[1129],{3180:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>j,frontMatter:()=>a,metadata:()=>d,toc:()=>o});var t=i(5893),s=i(1151),r=i(7618);i(4304);const a={title:"ActiveJ Inject Basics | Lightning-fast and ultimately powerful Dependency Injection Java library. Multithreaded friendly, feature-rich, and can boast with lighting-fast start-up time and runtime",description:"Extremely lightweight DI library. Multi-thread friendly, feature-rich, and can boast with lighting-fast start-up time and runtime - 5.5 times faster than Guice and 100s times faster than Spring.",sidebar_label:"Basics",keywords:["di","dependency injection","guice alternative","spring di","spring alternative","di benchmarks","java","java di","java dependency injection","java framework"]},c="Basics",d={id:"inject/basics",title:"ActiveJ Inject Basics | Lightning-fast and ultimately powerful Dependency Injection Java library. Multithreaded friendly, feature-rich, and can boast with lighting-fast start-up time and runtime",description:"Extremely lightweight DI library. Multi-thread friendly, feature-rich, and can boast with lighting-fast start-up time and runtime - 5.5 times faster than Guice and 100s times faster than Spring.",source:"@site/docs/inject/basics.mdx",sourceDirName:"inject",slug:"/inject/basics",permalink:"/inject/basics",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"ActiveJ Inject Basics | Lightning-fast and ultimately powerful Dependency Injection Java library. Multithreaded friendly, feature-rich, and can boast with lighting-fast start-up time and runtime",description:"Extremely lightweight DI library. Multi-thread friendly, feature-rich, and can boast with lighting-fast start-up time and runtime - 5.5 times faster than Guice and 100s times faster than Spring.",sidebar_label:"Basics",keywords:["di","dependency injection","guice alternative","spring di","spring alternative","di benchmarks","java","java di","java dependency injection","java framework"]},sidebar:"docs",previous:{title:"Overview",permalink:"/inject"},next:{title:"Quick Start",permalink:"/inject/quick-start"}},l={},o=[{value:"Key",id:"key",level:2},{value:"Binding",id:"binding",level:2},{value:"Module",id:"module",level:2},{value:"Injector",id:"injector",level:2},{value:"Scopes",id:"scopes",level:2}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"basics",children:"Basics"}),"\n",(0,t.jsx)(n.h2,{id:"key",children:"Key"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Applications are made up of components, and each component has an internal ",(0,t.jsx)(n.strong,{children:"id"})," called a ",(0,t.jsx)(r.Z,{text:"Key",url:"/core-inject/src/main/java/io/activej/inject/Key.java"})]}),"\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.code,{children:"Key"})," consists of a ",(0,t.jsx)(n.code,{children:"Type"})," and an optional ",(0,t.jsx)(n.code,{children:"Object"})," qualifier (useful when you want to distinguish between keys of the same ",(0,t.jsx)(n.code,{children:"Type"}),"):"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public class Key<T> {\n\t@NotNull\n\tprivate final Type type;\n\t@Nullable\n\tprivate final Object qualifier;\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.code,{children:"Key"})," type can be a simple Java ",(0,t.jsx)(n.code,{children:"Class"})," or a more complex ",(0,t.jsx)(n.code,{children:"ParameterizedType"}),", for example"]}),"\n",(0,t.jsxs)(n.li,{children:["There are multiple ways to create a ",(0,t.jsx)(n.code,{children:"Key"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["You can use ",(0,t.jsx)(n.code,{children:"Key.of(...)"}),", ",(0,t.jsx)(n.code,{children:"Key.ofType(...)"})," static factories"]}),"\n",(0,t.jsxs)(n.li,{children:["You can use an abstract ",(0,t.jsx)(n.code,{children:"Key"})," class directly by passing type as a generic parameter (useful for parameterized types)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"Key<Integer> integerKey = Key.of(Integer.class);\nKey<List<String>> listOfStringsKey = new Key<>(){};\n"})}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"Key"})," automatically simplifies any covariant (",(0,t.jsx)(n.code,{children:"? extends T"}),") or contravariant (",(0,t.jsx)(n.code,{children:"? super T"}),") types to ",(0,t.jsx)(n.code,{children:"T"}),"."]}),(0,t.jsx)(n.p,{children:"That is why the following is true:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"Key<List<? extends String>> covariantKey = new Key<>(){};\nKey<List<? super String>> contravariantKey = new Key<>(){};\n\nKey<List<String>> simpleKey = new Key<>(){};\n\ncovariantKey.equals(simpleKey); // true\ncontravariantKey.equals(simpleKey); // true\n"})})]}),"\n",(0,t.jsx)(n.h2,{id:"binding",children:"Binding"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Some dependencies may be required to create application components (an individual dependency can be defined by a ",(0,t.jsx)(n.code,{children:"Key"}),")."]}),"\n",(0,t.jsx)(n.li,{children:"Dependency Injection takes care of supplying application components with these required dependencies."}),"\n",(0,t.jsxs)(n.li,{children:["To do this, we need to specify ",(0,t.jsx)(n.strong,{children:"what"})," it should provide and ",(0,t.jsx)(n.strong,{children:"how"})," to use the provided objects."]}),"\n",(0,t.jsxs)(n.li,{children:["Therefore, a ",(0,t.jsx)(r.Z,{url:"/core-inject/src/main/java/io/activej/inject/binding/Binding.java",children:(0,t.jsx)(n.code,{children:"Binding"})}),"\ncontains a set of dependencies (",(0,t.jsx)(n.code,{children:"Key"}),"s) required to create some object. Additionally, a ",(0,t.jsx)(n.code,{children:"Binding"})," has a ",(0,t.jsx)(n.code,{children:"compile()"})," method which describes\nhow a binding should be compiled (how exactly the dependencies should be used to create the required object)."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public final class Binding<T> {\n     final Set<Key<?> dependencies;\n\n     public abstract CompiledBinding<T> compile(...);\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Binding"}),' is like a "recipe" for how to create an instance of a component:',"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"dependencies"})," show which ingredients should be used"]}),"\n",(0,t.jsxs)(n.li,{children:["the ",(0,t.jsx)(n.em,{children:"compile()"})," method describes how to cook them together"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Binding"}),"s are configured in ",(0,t.jsx)(n.code,{children:"Module"}),"s (modules will be explained ",(0,t.jsx)(n.a,{href:"#module",children:"later"}),").","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["You can either instantiate ",(0,t.jsx)(n.code,{children:"Binding"}),"s directly using static factory methods from the ",(0,t.jsx)(n.code,{children:"Binding"})," class, or you can use\n",(0,t.jsx)(n.code,{children:"ModuleBuilder"})," DSL to create modules that provide the required bindings"]}),"\n",(0,t.jsxs)(n.li,{children:["Alternatively, you can use the annotation-based approach to define bindings (methods annotated with ",(0,t.jsx)(n.code,{children:"@Provides"})," annotation)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"Module module1 = ModuleBuilder.create()\n\t.bind(String.class).to(integer -> integer.toString(), Integer.class)\n\t.build();\n\nModule module2 = new AbstractModule() {\n\t@Provides\n\tString string(Integer integer) {\n\t\treturn integer.toString();\n\t}\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"module1"})," is equivalent to ",(0,t.jsx)(n.code,{children:"module2"}),". Both define one single instance of ",(0,t.jsx)(n.code,{children:"String"})," ",(0,t.jsx)(n.code,{children:"Binding"}),", which has a single dependency on\nsome ",(0,t.jsx)(n.code,{children:"Integer"})," instance. A ",(0,t.jsx)(n.code,{children:"String"})," is created by calling the ",(0,t.jsx)(n.code,{children:"Integer#toString"})," method on an ",(0,t.jsx)(n.code,{children:"Integer"})," instance."]}),"\n",(0,t.jsx)(n.h2,{id:"module",children:"Module"}),"\n",(0,t.jsx)(n.p,{children:"A dependency graph is dificult to create directly, so we provide mechanisms for automatic transformation, generation and validation of a graph\nusing a simple but powerful DSL."}),"\n",(0,t.jsxs)(n.p,{children:["All these preprocessing steps are performed at start-up by compiling ",(0,t.jsx)(r.Z,{text:"Module",url:"/core-inject/src/main/java/io/activej/inject/module/Module.java"}),"s"]}),"\n",(0,t.jsx)(n.p,{children:"Each module exports several user-defined entities that help create a dependency graph:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["A trie of ",(0,t.jsx)(n.a,{href:"#binding",children:(0,t.jsx)(n.code,{children:"Bindings"})})," itself"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Multibinders that help resolve duplicate bindings (see ",(0,t.jsx)(n.a,{href:"/inject/duplicate-bindings",children:"example"}),")"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["BindingGenerators, which are used to automatically generate missing dependencies (see ",(0,t.jsx)(n.a,{href:"/inject/binding-generation",children:"example"}),")"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["BindingTransformers that transform certain bindings (see ",(0,t.jsx)(n.a,{href:"/inject/binding-transformation",children:"example"}),"):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"To intercept/modify/wrap provided instances"}),"\n",(0,t.jsx)(n.li,{children:"To intercept/modify/wrap the dependencies of provided instances"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public interface Module {\n    Trie<Scope, Map<Key<?>, Set<Binding<?>>>> getBindings();\n    Map<Key<?>, Multibinder<?>> getMultibinders();\n    Map<KeyPattern<?>, Set<BindingGenerator<?>>> getBindingGenerators();\n    Map<KeyPattern<?>, Set<BindingTransformer<?>>> getBindingTransformers();\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Multibinder"}),"s, ",(0,t.jsx)(n.strong,{children:"BindingGenerator"}),"s and ",(0,t.jsx)(n.strong,{children:"BindingTransformer"}),"s can be created using a clean and extremely simple Java8+ functional DSL"]}),"\n",(0,t.jsxs)(n.li,{children:["The resulting dependency graph is validated - checked for cyclic and missing dependencies, then compiled into a final scope tree and passed to the ",(0,t.jsx)(n.strong,{children:"Injector"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["It is trivial to manually implement the Module interface, but it is even easier to extend ",(0,t.jsx)(r.Z,{text:"AbstractModule",url:"/core-inject/src/main/java/io/activej/inject/module/AbstractModule.java"}),",\nwhich supports ",(0,t.jsx)(r.Z,{text:"@Provides",url:"/core-inject/src/main/java/io/activej/inject/annotation/Provides.java"})," method\nscanning and the DSL for creating/transforming/generating bindings."]}),"\n",(0,t.jsx)(n.h2,{id:"injector",children:"Injector"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(r.Z,{text:"Injector",url:"/core-inject/src/main/java/io/activej/inject/Injector.java"})," combines multiple modules\ntogether, resolves dependencies and allows you to obtain required instances"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Provides all the required dependencies (",(0,t.jsx)(n.em,{children:"injects"}),") for the component by\nrecursively traversing the dependencies graph in a postorder way, and creates them first."]}),"\n",(0,t.jsxs)(n.li,{children:["Bindings are singletons by default - if an instance was created once, it will not be recreated from scratch again. If\nyou need it for other bindings, ",(0,t.jsx)(n.strong,{children:"Injector"})," will take it from the cache. You don not need to apply any additional\nannotations for it."]}),"\n",(0,t.jsxs)(n.li,{children:["To provide the requested key, ",(0,t.jsx)(n.strong,{children:"Injector"})," recursively creates all its dependencies and falls back to injector of its\nparent ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.a,{href:"#scopes",children:"scope"})})," if no binding is found in its scope."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"scopes",children:"Scopes"}),"\n",(0,t.jsxs)(n.p,{children:["In short, a ",(0,t.jsx)(r.Z,{text:"Scope",url:"/core-inject/src/main/java/io/activej/inject/Scope.java"})," gives us \u201clocal singletons\u201d which live as long as the scope itself.\nActiveJ Inject scopes are a bit different from other DI libraries:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The internal structure of the ",(0,t.jsx)(n.strong,{children:"Injector"})," is a ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Trie",children:"prefix tree"})," and the prefix is a scope."]}),"\n",(0,t.jsx)(n.li,{children:"The identifiers (or prefixes) of the tree are simple annotations."}),"\n",(0,t.jsxs)(n.li,{children:["An ",(0,t.jsx)(n.code,{children:"Injector"})," can ",(0,t.jsx)(n.strong,{children:"enter the scope"}),". This means you create a new ",(0,t.jsx)(n.code,{children:"Injector"})," and its scope will be set to the one that it enters."]}),"\n",(0,t.jsxs)(n.li,{children:["This can be done multiple times, so you can have ",(0,t.jsx)(n.strong,{children:"N"})," injectors in certain scope."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public class Injector {\n ...\n    final Trie<Scope, ScopeLocalData> scopeDataTree;\n ...\n\n    public Injector enterScope(Scope scope) {\n        return new Injector(this, scopeDataTree.get(scope));\n    }\n ...\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"/inject/scopes",children:"This article"})," can show you how scopes work."]})]})}function j(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},7618:(e,n,i)=>{i.d(n,{Z:()=>r});i(7294);var t=i(9962),s=i(5893);const r=e=>{let{url:n,text:i,isInline:r=!0,children:a}=e;const{siteConfig:c}=(0,t.Z)(),d=n.startsWith("/examples")?c.customFields.githubExamplesBranch:c.customFields.githubBranch;return(0,s.jsx)("a",{style:r?{}:{display:"block",marginBottom:"16px"},href:c.customFields.githubUrl+"/"+d+n,target:"_blank",children:i||a})}},4304:(e,n,i)=>{i.d(n,{Z:()=>a});var t=i(7294),s=i(6365),r=i(5893);s.L.initialize({startOnLoad:!0});const a=e=>{let{chart:n}=e;return(0,t.useEffect)((()=>{s.L.contentLoaded()}),[]),(0,r.jsx)("div",{className:"mermaid",children:n})}}}]);